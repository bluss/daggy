var searchIndex = {};
searchIndex["daggy"] = {"doc":"**daggy** is a directed acyclic graph data structure library.","items":[[11,"new","petgraph::graph","",0,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[11,"index","","",0,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",0,{"inputs":[],"output":{"name":"edgeindex"}}],[11,"clone","petgraph::graphmap","",1,null],[11,"fmt","","",1,null],[11,"new","","Create a new `GraphMap`.",1,{"inputs":[],"output":{"name":"graphmap"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",1,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"graphmap"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",1,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",1,{"inputs":[{"name":"i"}],"output":{"name":"graphmap"}}],[11,"node_count","","Return the number of nodes in the graph.",1,null],[11,"edge_count","","Return the number of edges in the graph.",1,null],[11,"clear","","Remove all nodes and edges",1,null],[11,"add_node","","Add node `n` to the graph.",1,null],[11,"remove_node","","Return `true` if node `n` was removed.",1,null],[11,"contains_node","","Return `true` if the node is contained in the graph.",1,null],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph, with associated\ndata `weight`.",1,null],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",1,null],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",1,null],[11,"nodes","","Return an iterator over the nodes of the graph.",1,null],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",1,null],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",1,null],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",1,null],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",1,null],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",1,null],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"graphmap"}}],[11,"extend","","",1,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"next_back","","",3,null],[11,"clone","","",3,null],[11,"next","","",4,null],[11,"next","","",5,null],[11,"index","","",1,null],[11,"index_mut","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"graphmap"}}],[11,"clone","","",6,null],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",6,null],[11,"partial_cmp","","",6,null],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",6,null],[11,"deref","","",6,null],[11,"hash","","",6,null],[11,"fmt","","",6,null],[11,"hash","petgraph::graph","",7,null],[11,"cmp","","",7,null],[11,"partial_cmp","","",7,null],[11,"lt","","",7,null],[11,"le","","",7,null],[11,"gt","","",7,null],[11,"ge","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"new","","",7,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[11,"index","","",7,null],[11,"end","","",7,{"inputs":[],"output":{"name":"nodeindex"}}],[11,"from","","",7,{"inputs":[{"name":"ix"}],"output":{"name":"nodeindex"}}],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",9,null],[11,"source","","Return the source node index.",9,null],[11,"target","","Return the target node index.",9,null],[11,"clone","","",10,null],[11,"clone_from","","",10,null],[11,"fmt","","",10,null],[11,"new","","Create a new `Graph` with directed edges.",10,{"inputs":[],"output":{"name":"graph"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",10,{"inputs":[],"output":{"name":"graph"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",10,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"graph"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",10,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",10,null],[11,"edge_count","","Return the number of edges in the graph.",10,null],[11,"is_directed","","Whether the graph has directed edges or not.",10,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",10,null],[11,"node_weight","","Access the weight for node `a`.",10,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",10,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",10,null],[11,"update_edge","","Add or update an edge from `a` to `b`.\nIf the edge already exists, its weight is updated.",10,null],[11,"edge_weight","","Access the weight for edge `e`.",10,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",10,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",10,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",10,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",10,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",10,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",10,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",10,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",10,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",10,null],[11,"externals","","Return an iterator over either the nodes without edges to them\n(`Incoming`) or from them (`Outgoing`).",10,null],[11,"node_indices","","Return an iterator over the node indices of the graph",10,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",10,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",10,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",10,null],[11,"raw_nodes","","Access the internal node array.",10,null],[11,"raw_edges","","Access the internal edge array.",10,null],[11,"into_nodes_edges","","Convert the graph into a vector of Nodes and a vector of Edges",10,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",10,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",10,null],[11,"walk_edges_directed","","**Deprecated:** Use [`.neighbors_directed(a, dir).detach()`][1] instead.",10,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",10,null],[11,"reverse","","Reverse the direction of all edges",10,null],[11,"clear","","Remove all nodes and edges",10,null],[11,"clear_edges","","Remove all edges",10,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",10,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",10,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",10,{"inputs":[{"name":"i"}],"output":{"name":"graph"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",10,null],[11,"map","","Create a new `Graph` by mapping node and\nedge weights to new values.",10,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",10,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",10,null],[11,"next","","",11,null],[11,"next","","",12,null],[11,"clone","","",12,null],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",12,null],[11,"next","","",13,null],[11,"clone","","",13,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"default","","",10,{"inputs":[],"output":{"name":"graph"}}],[11,"index","","",7,null],[11,"is_node_index","","",7,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",0,null],[11,"is_node_index","","",0,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",16,null],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",16,null],[11,"next_node","","",16,null],[11,"next_edge","","",16,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"next","","Fetch the next edge index in the walk for graph `g`.",17,null],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",17,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"next_back","","",18,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"next","","",19,null],[11,"size_hint","","",19,null],[11,"next_back","","",19,null],[11,"new","petgraph::dot","Create a `Dot` formatting wrapper with default configuration.",20,{"inputs":[{"name":"g"}],"output":{"name":"dot"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",20,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"fmt","","",21,null],[11,"fmt","","",20,null],[11,"fmt","","",20,null],[11,"fmt","","",20,null],[11,"fmt","","",20,null],[11,"neighbors","petgraph::graph","",10,null],[11,"neighbors","petgraph::graphmap","",1,null],[11,"neighbors","petgraph::visit","",22,null],[11,"neighbors","","",23,null],[11,"neighbors_directed","petgraph::graph","",10,null],[11,"neighbors_directed","petgraph::visit","",23,null],[11,"externals","petgraph::graph","",10,null],[11,"externals","petgraph::visit","",23,null],[11,"visit","fixedbitset","",24,null],[11,"is_visited","","",24,null],[11,"visit","","",24,null],[11,"is_visited","","",24,null],[11,"visit","std::collections::hash::set","",25,null],[11,"is_visited","","",25,null],[11,"visit_map","petgraph::graph","",10,null],[11,"reset_map","","",10,null],[11,"reset_map","petgraph::visit","",23,null],[11,"visit_map","petgraph::graphmap","",1,null],[11,"reset_map","","",1,null],[11,"visit_map","petgraph::visit","",22,null],[11,"visit_map","","",23,null],[11,"adjacency_matrix","petgraph::graphmap","",1,null],[11,"is_adjacent","","",1,null],[11,"fmt","petgraph::visit","",26,null],[11,"clone","","",26,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",26,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"dfs"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",26,{"inputs":[{"name":"g"}],"output":{"name":"dfs"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",26,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",26,null],[11,"new","","",27,null],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",27,null],[11,"next","","",27,null],[11,"size_hint","","",27,null],[11,"clone","","",27,null],[11,"clone","","",28,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",28,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"bfs"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",28,null],[11,"new","","",29,null],[11,"next","","",29,null],[11,"size_hint","","",29,null],[11,"clone","","",29,null],[11,"clone","","",30,null],[11,"new","","Create a new `Topo`, using the graph&#39;s visitor map, and put all\ninitial nodes in the to-visit list.",30,{"inputs":[{"name":"g"}],"output":{"name":"topo"}}],[11,"reset","","Clear visited state, and put all initial nodes into the visit list.",30,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",30,null],[11,"clone","","",31,null],[11,"from_node","","Create a new `SubTopo`, using the graph&#39;s visitor map, and put single\nnode in the to-visit list.",31,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"subtopo"}}],[11,"reset_with_node","","Clear visited state, and put a single node into the visit list.",31,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",31,null],[11,"clone","petgraph::unionfind","",32,null],[11,"fmt","","",32,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",32,{"inputs":[{"name":"usize"}],"output":{"name":"unionfind"}}],[11,"find","","Return the representative for `x`.",32,null],[11,"find_mut","","Return the representative for `x`.",32,null],[11,"union","","Unify the two sets containing `x` and `y`.",32,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",32,null],[11,"adjacency_matrix","petgraph::graph","",10,null],[11,"is_adjacent","","",10,null],[11,"hash","petgraph","",33,null],[11,"cmp","","",33,null],[11,"partial_cmp","","",33,null],[11,"eq","","",33,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"opposite","","Return the opposite `EdgeDirection`.",33,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"fmt","","",35,null],[11,"clone","","",35,null],[11,"is_directed","","",34,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",35,{"inputs":[],"output":{"name":"bool"}}],[3,"EdgeIndex","daggy","Edge identifier.",null,null],[3,"NodeIndex","","Node identifier.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"Dag","","A Directed acyclic graph (DAG) data structure.",null,null],[3,"Children","","A **Walker** type that can be used to step through the children of some parent node.",null,null],[3,"Parents","","A **Walker** type that can be used to step through the children of some parent node.",null,null],[3,"EdgeIndices","","An iterator yielding multiple `EdgeIndex`s, returned by the `Graph::add_edges` method.",null,null],[3,"WouldCycle","","An error returned by the `Dag::add_edge` method in the case that adding an edge would have\ncaused the graph to cycle.",null,null],[12,"0","","",36,null],[0,"walker","","**Walker** is a trait providing a variety of useful methods for traversing graph types.",null,null],[3,"Recursive","daggy::walker","Recursively walks a graph using the recursive function `recursive_fn`.",null,null],[3,"Chain","","Walks the entirety of `a` before walking the entirety of `b`.",null,null],[3,"Filter","","A walker that applies some given predicate to each element returned by its walker.\nThe only index pairs that will be yielded are those that make the predicate evaluate to true.",null,null],[3,"Peekable","","A walker that has a `.peek(&amp;graph)` method that returns an optional next neighbor.",null,null],[3,"SkipWhile","","A walker that invokes the predicate on elements until it returns false. Once the predicate\nreturns false, that element and all further elements are yielded.",null,null],[3,"TakeWhile","","A walker that yields elements so long as the predicate returns true. After the\npredicate returns false for the first time, no further elements will be yielded.",null,null],[3,"Skip","","A walker that skips the first n steps of this walk, and then yields all further steps.",null,null],[3,"Take","","A walker that yields the first n steps of this walk.",null,null],[3,"Cycle","","A walker that repeats its internal walker endlessly.",null,null],[3,"Inspect","","A walker that calls a function with a reference to each index pair before yielding them.\nThis is often useful for debugging a walker pipeline.",null,null],[3,"Iter","","An iterator yielding index pairs produced by its internal walker and graph.",null,null],[3,"IterEdges","","An iterator yielding edge indices produced by its internal walker and graph.",null,null],[3,"IterNodes","","An iterator yielding node indices produced by its internal walker and graph.",null,null],[3,"IterWeights","","An iterator yielding weights associated with the index pairs produced by its internal walker\nand graph.",null,null],[3,"IterEdgeWeights","","An iterator yielding edge weights associated with the indices produced by its internal walker\nand graph.",null,null],[3,"IterNodeWeights","","An iterator yielding node weights associated with the indices produced by its internal walker\nand graph.",null,null],[6,"IndexPair","","Short-hand for an edge node index pair.",null,null],[8,"Walker","","A trait providing a variety of useful methods for traversing some graph type **G**.",null,null],[16,"Index","","The unsigned integer type used for node and edge indices.",37,null],[10,"next","","Fetch the `EdgeIndex` and `NodeIndex` to the next neighbour in our walk through the given\n**Graph**.",37,null],[11,"next_edge","","The next edge in our walk for the given **Graph**.",37,null],[11,"next_node","","The next node in our walk for the given **Graph**.",37,null],[11,"count","","Counts all the steps in the entire walk of the given graph.",37,null],[11,"last","","Walks the whole walk until reaching and returning the last edge node pair.",37,null],[11,"last_edge","","Walks the whole walk until reaching and returning the last edge.",37,null],[11,"last_node","","Walks the whole walk until reaching and returning the last node.",37,null],[11,"nth","","Walks &quot;n&quot; number of steps and produces the resulting edge node pair.",37,null],[11,"nth_edge","","Walks &quot;n&quot; number of steps and produces the resulting edge.",37,null],[11,"nth_node","","Walks &quot;n&quot; number of steps and produces the resulting node.",37,null],[11,"chain","","Produces a walker that will walk the entirey of `self` before walking the entirey of other.",37,null],[11,"filter","","Creates a walker that applies the predicate to each element returned by this walker.\nThe only elements that will be yielded are those that make the predicate evaluate to true.",37,null],[11,"peekable","","Creates a walker that has a `.peek(&amp;graph)` method that returns an optional next neighbor.",37,null],[11,"skip_while","","Creates a walker that invokes the predicate on elements until it returns false. Once the\npredicate returns false, that element and all further elements are yielded.",37,null],[11,"take_while","","Creates a walker that yields elements so long as the predicate returns true. After the\npredicate returns false for the first time, no further elements will be yielded.",37,null],[11,"skip","","Creates a walker that skips the first n steps of this walk, and then yields all further\nsteps.",37,null],[11,"take","","Creates a walker that yields the first n steps of this walk.",37,null],[11,"all","","Tests whether the predicate holds true for all steps in the walk.",37,null],[11,"any","","Tests whether any step in the walk satisfies the given predicate.",37,null],[11,"find","","Returns the first edge node index pair satisfying the specified predicate.",37,null],[11,"find_edge","","Returns the edge index satisfying the specified predicate.",37,null],[11,"find_node","","Returns the node index satisfying the specified predicate.",37,null],[11,"cycle","","Repeats the walker endlessly.",37,null],[11,"fold","","Performs a fold operation over the entire walker, returning the eventual state at the end\nof the walk.",37,null],[11,"inspect","","Creates a walker that calls a function with a reference to each index pair before yielding\nthem. This is often useful for debugging a walker pipeline.",37,null],[11,"iter","","Converts the walker into an iterator yielding index pairs.",37,null],[11,"iter_weights","","Converts the walker into an iterator yielding `(&amp;e, &amp;n)`, where `e` is the edge weight for\nthe next `EdgeIndex` and `n` is the node weight for the next `NodeIndex`.",37,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"new","","Construct a new **Recursive** **Walker** starting from the node at the given index.",38,{"inputs":[{"name":"nodeindex"},{"name":"f"}],"output":{"name":"self"}}],[11,"next","","",38,null],[11,"fmt","","",39,null],[11,"clone","","",39,null],[11,"next","","",39,null],[11,"fmt","","",40,null],[11,"clone","","",40,null],[11,"next","","",40,null],[11,"fmt","","",41,null],[11,"clone","","",41,null],[11,"peek","","The edge node index pair of the neighbor at the next step in our walk of the given graph.",41,null],[11,"peek_edge","","The edge index of the neighbor at the next step in our walk of the given graph.",41,null],[11,"peek_node","","The node index of the neighbor at the next step in our walk of the given graph.",41,null],[11,"next","","",41,null],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"next","","",42,null],[11,"fmt","","",43,null],[11,"clone","","",43,null],[11,"next","","",43,null],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"next","","",44,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"next","","",45,null],[11,"fmt","","",46,null],[11,"clone","","",46,null],[11,"next","","",46,null],[11,"fmt","","",47,null],[11,"clone","","",47,null],[11,"next","","",47,null],[11,"fmt","","",48,null],[11,"clone","","",48,null],[11,"edges","","Convert to an iterator that only yields the edge indices.",48,null],[11,"nodes","","Convert to an iterator that only yields the node indices.",48,null],[11,"next","","",48,null],[11,"fmt","","",49,null],[11,"clone","","",49,null],[11,"next","","",49,null],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"next","","",50,null],[11,"fmt","","",51,null],[11,"clone","","",51,null],[11,"edges","","Convert to an iterator yielding only the edge weights.",51,null],[11,"nodes","","Convert to an iterator yielding only the node weights.",51,null],[11,"next","","",51,null],[11,"fmt","","",52,null],[11,"clone","","",52,null],[11,"next","","",52,null],[11,"fmt","","",53,null],[11,"clone","","",53,null],[11,"next","","",53,null],[6,"PetGraph","daggy","The Petgraph to be used internally within the Dag for storing/managing nodes and edges.",null,null],[6,"RawNodes","","Read only access into a **Dag**&#39;s internal node array.",null,null],[6,"RawEdges","","Read only access into a **Dag**&#39;s internal edge array.",null,null],[6,"RecursiveWalk","","An alias to simplify the **Recursive** **Walker** type returned by **Dag**.",null,null],[11,"fmt","","",54,null],[11,"clone","","",54,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"new","","Create a new, empty `Dag`.",54,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Dag` with estimated capacity for its node and edge Vecs.",54,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clear","","Removes all nodes and edges from the **Dag**.",54,null],[11,"node_count","","The total number of nodes in the **Dag**.",54,null],[11,"edge_count","","The total number of edgees in the **Dag**.",54,null],[11,"graph","","Borrow the `Dag`&#39;s underlying `PetGraph&lt;N, Ix&gt;`.\nAll existing indices may be used to index into this `PetGraph` the same way they may be\nused to index into the `Dag`.",54,null],[11,"into_graph","","Take ownership of the `Dag` and return the internal `PetGraph`.\nAll existing indices may be used to index into this `PetGraph` the same way they may be\nused to index into the `Dag`.",54,null],[11,"add_node","","Add a new node to the `Dag` with the given weight.",54,null],[11,"add_edge","","Add a new directed edge to the `Dag` with the given weight.",54,null],[11,"add_edges","","Adds the given directed edges to the `Dag`, each with their own given weight.",54,null],[11,"update_edge","","Update the edge from nodes `a` -&gt; `b` with the given weight.",54,null],[11,"find_edge","","Find and return the index to the edge that describes `a` -&gt; `b` if there is one.",54,null],[11,"edge_endpoints","","Access the parent and child nodes for the given `EdgeIndex`.",54,null],[11,"clear_edges","","Remove all edges.",54,null],[11,"add_parent","","Add a new edge and parent node to the node at the given `NodeIndex`.\nReturns both the edge&#39;s `EdgeIndex` and the node&#39;s `NodeIndex`.",54,null],[11,"add_child","","Add a new edge and child node to the node at the given `NodeIndex`.\nReturns both the edge&#39;s `EdgeIndex` and the node&#39;s `NodeIndex`.",54,null],[11,"node_weight","","Borrow the weight from the node at the given index.",54,null],[11,"node_weight_mut","","Mutably borrow the weight from the node at the given index.",54,null],[11,"raw_nodes","","Read from the internal node array.",54,null],[11,"node_weights_mut","","An iterator yielding mutable access to all node weights.",54,null],[11,"edge_weight","","Borrow the weight from the edge at the given index.",54,null],[11,"edge_weight_mut","","Mutably borrow the weight from the edge at the given index.",54,null],[11,"raw_edges","","Read from the internal edge array.",54,null],[11,"edge_weights_mut","","An iterator yielding mutable access to all edge weights.",54,null],[11,"index_twice_mut","","Index the `Dag` by two indices.",54,null],[11,"remove_node","","Remove the node at the given index from the `Dag` and return it if it exists.",54,null],[11,"remove_edge","","Remove an edge and return its weight, or `None` if it didn&#39;t exist.",54,null],[11,"parents","","A **Walker** type that may be used to step through the parents of the given child node.",54,null],[11,"children","","A &quot;walker&quot; object that may be used to step through the children of the given parent node.",54,null],[11,"recursive_walk","","A **Walker** type that recursively walks the **Dag** using the given `recursive_fn`.",54,null],[11,"index","","",54,null],[11,"index_mut","","",54,null],[11,"index","","",54,null],[11,"index_mut","","",54,null],[11,"next","","",55,null],[11,"next","","",56,null],[11,"next","","",57,null],[11,"fmt","","",36,null],[11,"description","","",36,null]],"paths":[[3,"EdgeIndex"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Edges"],[3,"AllEdges"],[3,"Ptr"],[3,"NodeIndex"],[3,"Node"],[3,"Edge"],[3,"Graph"],[3,"Externals"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkNeighbors"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[3,"Dot"],[4,"Config"],[3,"AsUndirected"],[3,"Reversed"],[3,"FixedBitSet"],[3,"HashSet"],[3,"Dfs"],[3,"DfsIter"],[3,"Bfs"],[3,"BfsIter"],[3,"Topo"],[3,"SubTopo"],[3,"UnionFind"],[4,"EdgeDirection"],[4,"Directed"],[4,"Undirected"],[3,"WouldCycle"],[8,"Walker"],[3,"Recursive"],[3,"Chain"],[3,"Filter"],[3,"Peekable"],[3,"SkipWhile"],[3,"TakeWhile"],[3,"Skip"],[3,"Take"],[3,"Cycle"],[3,"Inspect"],[3,"Iter"],[3,"IterEdges"],[3,"IterNodes"],[3,"IterWeights"],[3,"IterEdgeWeights"],[3,"IterNodeWeights"],[3,"Dag"],[3,"Children"],[3,"Parents"],[3,"EdgeIndices"]]};
searchIndex["petgraph"] = {"doc":"**petgraph** is a graph data structure library.","items":[[4,"EdgeDirection","petgraph","Edge direction",null,null],[13,"Outgoing","","An `Outgoing` edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An `Incoming` edge is an inbound edge *to* the current node.",0,null],[4,"Directed","","Marker type for a directed graph.",null,null],[4,"Undirected","","Marker type for an undirected graph.",null,null],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_isomorphic_matching","","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra&#39;s shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return `true` if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to `is_cyclic_undirected`.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Return `true` if the input directed graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute the *strongly connected components* using Kosaraju&#39;s algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"condensation","","Condense every strongly connected component into a single node and return the result.",null,{"inputs":[{"name":"graph"},{"name":"bool"}],"output":{"name":"graph"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Compute a *minimum spanning tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"graphmap","petgraph","`GraphMap&lt;N, E&gt;` is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","`GraphMap&lt;N, E&gt;` is an undirected graph, with generic node values `N` and edge weights `E`.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[3,"AllEdges","","",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[12,"0","","",1,null],[8,"NodeTrait","","A trait group for `GraphMap`&#39;s node identifier.",null,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"new","","Create a new `GraphMap`.",2,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",2,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",2,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes in the graph.",2,null],[11,"edge_count","","Return the number of edges in the graph.",2,null],[11,"clear","","Remove all nodes and edges",2,null],[11,"add_node","","Add node `n` to the graph.",2,null],[11,"remove_node","","Return `true` if node `n` was removed.",2,null],[11,"contains_node","","Return `true` if the node is contained in the graph.",2,null],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph, with associated\ndata `weight`.",2,null],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",2,null],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",2,null],[11,"nodes","","Return an iterator over the nodes of the graph.",2,null],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",2,null],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",2,null],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,null],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,null],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",2,null],[11,"from_iter","","",2,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"clone","","",4,null],[11,"next","","",5,null],[11,"next","","",6,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",1,null],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",1,null],[11,"deref","","",1,null],[11,"hash","","",1,null],[11,"fmt","","",1,null],[0,"graph","petgraph","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph&#39;s node type.",null,null],[12,"weight","","Associated node data.",7,null],[3,"Edge","","The graph&#39;s edge type.",null,null],[12,"weight","","Associated edge data.",8,null],[3,"Graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"Externals","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"WalkNeighbors","","A “walker” object that can be used to step through the edge list of a node.",null,null],[3,"WalkEdges","","**Deprecated.**",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[3,"EdgeIndices","","Iterator over the edge indices of a graph.",null,null],[5,"node_index","","Short version of `NodeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[5,"edge_index","","Short version of `EdgeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[6,"DefIndex","","The default integer type for node and edge indices in `Graph`.\n`u32` is the default to reduce the size of the graph&#39;s data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",9,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",9,null],[10,"max","","",9,{"inputs":[],"output":{"name":"self"}}],[8,"GraphIndex","","A  `GraphIndex` is a node or edge index.",null,null],[11,"hash","","",10,null],[11,"cmp","","",10,null],[11,"partial_cmp","","",10,null],[11,"lt","","",10,null],[11,"le","","",10,null],[11,"gt","","",10,null],[11,"ge","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"new","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",10,null],[11,"end","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"from","","",10,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"hash","","",11,null],[11,"cmp","","",11,null],[11,"partial_cmp","","",11,null],[11,"lt","","",11,null],[11,"le","","",11,null],[11,"gt","","",11,null],[11,"ge","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"clone","","",11,null],[11,"new","","",11,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",11,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",11,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",11,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",8,null],[11,"source","","Return the source node index.",8,null],[11,"target","","Return the target node index.",8,null],[11,"clone","","",12,null],[11,"clone_from","","",12,null],[11,"fmt","","",12,null],[11,"new","","Create a new `Graph` with directed edges.",12,{"inputs":[],"output":{"name":"self"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",12,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",12,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",12,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",12,null],[11,"edge_count","","Return the number of edges in the graph.",12,null],[11,"is_directed","","Whether the graph has directed edges or not.",12,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",12,null],[11,"node_weight","","Access the weight for node `a`.",12,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",12,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",12,null],[11,"update_edge","","Add or update an edge from `a` to `b`.\nIf the edge already exists, its weight is updated.",12,null],[11,"edge_weight","","Access the weight for edge `e`.",12,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",12,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",12,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",12,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",12,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",12,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",12,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",12,null],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",12,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",12,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",12,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",12,null],[11,"externals","","Return an iterator over either the nodes without edges to them\n(`Incoming`) or from them (`Outgoing`).",12,null],[11,"node_indices","","Return an iterator over the node indices of the graph",12,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",12,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",12,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",12,null],[11,"raw_nodes","","Access the internal node array.",12,null],[11,"raw_edges","","Access the internal edge array.",12,null],[11,"into_nodes_edges","","Convert the graph into a vector of Nodes and a vector of Edges",12,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",12,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",12,null],[11,"walk_edges_directed","","**Deprecated:** Use [`.neighbors_directed(a, dir).detach()`][1] instead.",12,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",12,null],[11,"reverse","","Reverse the direction of all edges",12,null],[11,"clear","","Remove all nodes and edges",12,null],[11,"clear_edges","","Remove all edges",12,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",12,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",12,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",12,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",12,null],[11,"map","","Create a new `Graph` by mapping node and\nedge weights to new values.",12,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",12,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",12,null],[11,"next","","",13,null],[11,"next","","",14,null],[11,"clone","","",14,null],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",14,null],[11,"next","","",15,null],[11,"clone","","",15,null],[11,"next","","",16,null],[11,"size_hint","","",16,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"index","","",12,null],[11,"index_mut","","",12,null],[11,"index","","",12,null],[11,"index_mut","","",12,null],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",10,null],[11,"is_node_index","","",10,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",11,null],[11,"is_node_index","","",11,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",18,null],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",18,null],[11,"next_node","","",18,null],[11,"next_edge","","",18,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"next","","Fetch the next edge index in the walk for graph `g`.",19,null],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",19,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"next_back","","",20,null],[11,"fmt","","",21,null],[11,"clone","","",21,null],[11,"next","","",21,null],[11,"size_hint","","",21,null],[11,"next_back","","",21,null],[0,"dot","petgraph","Simple graphviz dot file format output.",null,null],[3,"Dot","petgraph::dot","`Dot` implements output to graphviz .dot format for a graph.",null,null],[4,"Config","","`Dot` configuration.",null,null],[13,"NodeIndexLabel","","Use indices for node labels.",22,null],[13,"EdgeIndexLabel","","Use indices for edge labels.",22,null],[13,"EdgeNoLabel","","Use no edge labels.",22,null],[11,"new","","Create a `Dot` formatting wrapper with default configuration.",23,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",23,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"fmt","","",22,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[12,"0","","",24,null],[3,"Reversed","","Wrapper type for walking the graph as if all edges are reversed.",null,null],[12,"0","","",25,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","The stack of nodes to visit",26,null],[12,"discovered","","The map of discovered nodes",26,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",27,null],[12,"discovered","","The map of discovered nodes",27,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[3,"Topo","","A topological order traversal for a graph.",null,null],[3,"SubTopo","","A topological order traversal for a subgraph.",null,null],[8,"Graphlike","","Base trait for graphs that defines the node identifier.",null,null],[16,"NodeId","","",28,null],[8,"NeighborIter","","NeighborIter gives access to the neighbors iterator.",null,null],[16,"Iter","","",29,null],[10,"neighbors","","Return an iterator that visits all neighbors of the node **n**.",29,null],[8,"NeighborsDirected","","NeighborsDirected gives access to neighbors of both `Incoming` and `Outgoing`\nedges of a node.",null,null],[16,"NeighborsDirected","","",30,null],[10,"neighbors_directed","","Return an iterator that visits all neighbors of the node **n**.",30,null],[8,"Externals","","Externals returns an iterator of all nodes that either have either no\nincoming or no outgoing edges.",null,null],[16,"Externals","","",31,null],[10,"externals","","Return an iterator of all nodes with no edges in the given direction",31,null],[8,"VisitMap","","A mapping for storing the visited status for NodeId `N`.",null,null],[10,"visit","","Return **true** if the value is not already present.",32,null],[10,"is_visited","","",32,null],[8,"Visitable","","A graph that can create a visitor map.",null,null],[16,"Map","","",33,null],[10,"visit_map","","",33,null],[8,"Revisitable","","A graph that can reset and resize its visitor map.",null,null],[10,"reset_map","","",34,null],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","","",35,null],[10,"adjacency_matrix","","",35,null],[10,"is_adjacent","","",35,null],[11,"neighbors","petgraph::graph","",12,null],[11,"neighbors","petgraph::graphmap","",2,null],[11,"neighbors","petgraph::visit","",24,null],[11,"neighbors","","",25,null],[11,"neighbors_directed","petgraph::graph","",12,null],[11,"neighbors_directed","petgraph::visit","",25,null],[11,"externals","petgraph::graph","",12,null],[11,"externals","petgraph::visit","",25,null],[11,"visit","fixedbitset","",36,null],[11,"is_visited","","",36,null],[11,"visit","","",36,null],[11,"is_visited","","",36,null],[11,"visit","std::collections::hash::set","",37,null],[11,"is_visited","","",37,null],[11,"visit_map","petgraph::graph","",12,null],[11,"reset_map","","",12,null],[11,"reset_map","petgraph::visit","",25,null],[11,"visit_map","petgraph::graphmap","",2,null],[11,"reset_map","","",2,null],[11,"visit_map","petgraph::visit","",24,null],[11,"visit_map","","",25,null],[11,"adjacency_matrix","petgraph::graphmap","",2,null],[11,"is_adjacent","","",2,null],[11,"fmt","petgraph::visit","",26,null],[11,"clone","","",26,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",26,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",26,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",26,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",26,null],[11,"new","","",38,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",38,null],[11,"next","","",38,null],[11,"size_hint","","",38,null],[11,"clone","","",38,null],[11,"clone","","",27,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",27,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",27,null],[11,"new","","",39,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"next","","",39,null],[11,"size_hint","","",39,null],[11,"clone","","",39,null],[11,"clone","","",40,null],[11,"new","","Create a new `Topo`, using the graph&#39;s visitor map, and put all\ninitial nodes in the to-visit list.",40,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear visited state, and put all initial nodes into the visit list.",40,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",40,null],[11,"clone","","",41,null],[11,"from_node","","Create a new `SubTopo`, using the graph&#39;s visitor map, and put single\nnode in the to-visit list.",41,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"reset_with_node","","Clear visited state, and put a single node into the visit list.",41,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",41,null],[0,"unionfind","petgraph","`UnionFind&lt;K&gt;` is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","`UnionFind&lt;K&gt;` is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.",null,null],[11,"clone","","",42,null],[11,"fmt","","",42,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",42,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for `x`.",42,null],[11,"find_mut","","Return the representative for `x`.",42,null],[11,"union","","Unify the two sets containing `x` and `y`.",42,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",42,null],[11,"adjacency_matrix","petgraph::graph","",12,null],[11,"is_adjacent","","",12,null],[8,"EdgeType","petgraph","A graph&#39;s edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",43,{"inputs":[],"output":{"name":"bool"}}],[8,"IntoWeightedEdge","","Convert an element like `(i, j)` or `(i, j, w)` into\na triple of source, target, edge weight.",null,null],[16,"NodeId","","",44,null],[10,"into_weighted_edge","","",44,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"opposite","","Return the opposite `EdgeDirection`.",0,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"fmt","","",46,null],[11,"clone","","",46,null],[11,"is_directed","","",45,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",46,{"inputs":[],"output":{"name":"bool"}}]],"paths":[[4,"EdgeDirection"],[3,"Ptr"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Edges"],[3,"AllEdges"],[3,"Node"],[3,"Edge"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"Externals"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkNeighbors"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[4,"Config"],[3,"Dot"],[3,"AsUndirected"],[3,"Reversed"],[3,"Dfs"],[3,"Bfs"],[8,"Graphlike"],[8,"NeighborIter"],[8,"NeighborsDirected"],[8,"Externals"],[8,"VisitMap"],[8,"Visitable"],[8,"Revisitable"],[8,"GetAdjacencyMatrix"],[3,"FixedBitSet"],[3,"HashSet"],[3,"DfsIter"],[3,"BfsIter"],[3,"Topo"],[3,"SubTopo"],[3,"UnionFind"],[8,"EdgeType"],[8,"IntoWeightedEdge"],[4,"Directed"],[4,"Undirected"]]};
searchIndex["fixedbitset"] = {"doc":"**FixedBitSet** is a simple fixed size set of bits.","items":[[3,"FixedBitSet","fixedbitset","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"grow","","Grow capacity to **bits**, all new bits initialized to zero",0,null],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,null],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,null],[11,"clear","","Clear all bits.",0,null],[11,"insert","","**Panics** if **bit** is out of bounds.",0,null],[11,"set","","**Panics** if **bit** is out of bounds.",0,null],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,null],[11,"index","","",0,null]],"paths":[[3,"FixedBitSet"]]};
initSearch(searchIndex);
